from fastapi import APIRouter, HTTPException
from app.models.car import DiagnosticRequest, DiagnosticResponse
from app.services import diagnostic_service
import uuid

router = APIRouter()

@router.post("/", response_model=DiagnosticResponse)
async def get_diagnosis(request: DiagnosticRequest) -> DiagnosticResponse:
    """
    This endpoint is the core of the diagnostic conversation.

    - It receives the user's latest message and conversation history.
    - It calls the diagnostic service to determine the next step.
    - It returns the bot's response to continue the conversation.
    """
    if not request.history:
        raise HTTPException(status_code=400, detail="Conversation history cannot be empty.")

    # Get the latest message from the user
    last_message = request.history[-1]

    # Call the diagnostic service to get the bot's next response
    response_text = diagnostic_service.get_mock_diagnostic_response(last_message)

    # In a real session, you'd create and track a unique ID
    session_id = request.session_id or str(uuid.uuid4())

    # Mocked possible causes and confidence for this stage of development
    # This would be dynamically generated by the ML model in a real application
    return DiagnosticResponse(
        session_id=session_id,
        bot_response=response_text,
        possible_causes=["Analysis in progress..."],
        confidence_score=0.5
    )
